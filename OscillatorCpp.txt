#include "Oscillator.h"
#include <random>
#include <time.h>
#include <iostream>

//Creator for an Oscillator, it takes the coordinates, the index, the topology of the coupling, the dimension as the number of oscillators in the system and the coupling strengh
Oscillator::Oscillator(double x, double y, int index, int couplingMatrix[], int dimension, double couplingStrengh)
{
	std::cout << "Constructing an Oscillator!\n";
	_x[0] = x;
	_y[0] = y;
	_index = index;
	_couplingStrengh = couplingStrengh;

	setCoupling(couplingMatrix, index, dimension);
}

//Destructor for an oscillators (Should never be used)
Oscillator::~Oscillator()
{
	std::cout << "The Destructor of the Oscillator is called!\n";
}

//Reading the coupling from a matrix.txt file. Ever oscillator saves its coupling to the other oscillators. Saves later time in the calculation
void Oscillator::setCoupling(int matrix[], int index, int dimension)
{
	for (int i = 0; i < dimension; i++) {
		if (matrix[index * dimension + i] == 1) {
			_couplings.push_back(i);
		}
	}
}

//Returns the coupling-topology of this oscillator
std::string Oscillator::getCoupling()
{
	std::string coupling = "";
	for (unsigned int i = 0; i < _couplings.size(); i++) {
		coupling = coupling + std::to_string(_couplings[i]);
	}
	return coupling;
}

//Basic euler step for integrating the differential eq.
void Oscillator::eulerStep(std::vector<Oscillator*> oscillators, const double b)
{
	_dx[0] = 0.0f;
	_dy[0] = 0.0f;
	_dx[0] = (_x[0] * (1 - _x[0] * _x[0] - _y[0] * _y[0]) + _y[0] * (_x[0] - b));
	_dy[0] = (_y[0] * (1 - _x[0] * _x[0] - _y[0] * _y[0]) - _x[0] * (_x[0] - b));
	for (unsigned int i = 0; i < _couplings.size(); i++){
		_dx[0] += _couplingStrengh * ((oscillators[i]->getX(0) - _x[0]) + (oscillators[i]->getY(0)) - _y[0]);
		_dy[0] += _couplingStrengh * ((oscillators[i]->getX(0) - _x[0]) + (oscillators[i]->getY(0)) - _y[0]);
	}
}

//Applying the dx_dy step for euler
void Oscillator::nextStep(const double stepSize)
{
	_x[0] += _dx[0] * stepSize;
	_y[0] += _dy[0] * stepSize;
}

//Runge-Kutta-4 for solving the diff. eq.
void Oscillator::rungeKutta(std::vector<Oscillator*> oscillators, const int coordinateIndex, const double b)
{
	_dx[coordinateIndex] = 0.0f;
	_dy[coordinateIndex] = 0.0f;
	_dx[coordinateIndex] = (_x[coordinateIndex] * (1 - _x[coordinateIndex] * _x[coordinateIndex] - _y[coordinateIndex] * _y[coordinateIndex]) + _y[coordinateIndex] * (_x[coordinateIndex] - b));
	_dy[coordinateIndex] = (_y[coordinateIndex] * (1 - _x[coordinateIndex] * _x[coordinateIndex] - _y[coordinateIndex] * _y[coordinateIndex]) - _x[coordinateIndex] * (_x[coordinateIndex] - b));
	for (unsigned int i = 0; i < _couplings.size(); i++) {
		_dx[coordinateIndex] += _couplingStrengh * ((oscillators[_couplings[i]]->getX(coordinateIndex) - _x[coordinateIndex]) + (oscillators[_couplings[i]]->getY(coordinateIndex)) - _y[coordinateIndex]);
		_dy[coordinateIndex] += _couplingStrengh * ((oscillators[_couplings[i]]->getX(coordinateIndex) - _x[coordinateIndex]) + (oscillators[_couplings[i]]->getY(coordinateIndex)) - _y[coordinateIndex]);
	}
}

//Applying the dx_dy step for runge kutta (This is just applying the part steps in runge kutta)
void Oscillator::nextRungeStep(const int coordinateIndex, const double stepSize)
{
	_x[coordinateIndex + 1] = _x[0] + _dx[coordinateIndex] * stepSize;
	_y[coordinateIndex + 1] = _y[0] + _dy[coordinateIndex] * stepSize;
}

//Applying alle rungeParts as a whole step to the main coordinates _x[0] _y[0]
void Oscillator::finalRungeStep(const double stepSize)
{
	double multiplicator = 0.166666f;
	_x[0] += (multiplicator * (_dx[0] + 2 * _dx[1] + 2 * _dx[2] + _dx[3]) * stepSize);
	_y[0] += (multiplicator * (_dy[0] + 2 * _dy[1] + 2 * _dy[2] + _dy[3]) * stepSize);
}