#include <iostream>
#include <vector>
#include <time.h>
#include <random>
#include <fstream>
#include <string>
#include "Oscillator.h"

//For now we use global constants
const int NUMBER_OSCILLATORS = 100; //Number of Oscillators in the system (Duh!)
const double STEP_SIZE = 0.001f; //Step Size for the runge kuta or the euler integration
const double COUPLING_STRENGH = 0.1f; //Coupling strengh
const double VARIABLE_B = 9.0f; //Synchronizing factor in the equation for the SNIPER-Model
const int TIMESTEPS = 5000; //Timesteps of the system. So to get the whole time of the simulation do TIMESTEPS * STEP_SIZE


int main()
{
	//Creating the random engine and seeding it with the time
	std::mt19937 mt_rand(time(0));
	std::uniform_real<double> rand_double(0, 1);

	//Reading the coupling from a file
	std::ifstream couplingMatrix("Kopplungsmatrix.txt");
	if (couplingMatrix.fail())
	{
		perror("Kopplungsmatrix.txt");
	}

	//Pushing the coupling into a vector of strings
	std::vector<std::string> rows;
	std::string number;
	while (getline(couplingMatrix, number))
	{
		rows.push_back(number);
	}

	//Changing the coupling into an array of numbers
	int matrix[NUMBER_OSCILLATORS * NUMBER_OSCILLATORS];
	for (unsigned int i = 0; i < rows.size(); i++) {
		for (unsigned int j = 0; j < rows[i].size(); j++) {
			matrix[rows.size()*i + j] = rows[i][j] - '0';
		}
	}

	//Vector of Object pointers for the oscillators
	std::vector<Oscillator*> oscillators;

	//Creating the objects, oscillators, and pushing them into the vector of pointers
	for (int i = 0; i < NUMBER_OSCILLATORS; i++) {
		Oscillator *tmp = new Oscillator(rand_double(mt_rand), rand_double(mt_rand), i, matrix, NUMBER_OSCILLATORS, COUPLING_STRENGH);
		oscillators.push_back(tmp);
	}

	//Open file for saving the data
	std::ofstream outputFile;
	outputFile.open("C:/Users/Felix/PycharmProjects/Masterarbeit/Data.txt");
	if (outputFile.fail())
	{
		perror("Data.txt");
		return 1;
	}

	//Main loop of the simulation
	int steps = 0; //Steps counting for the simulation
	while (steps < TIMESTEPS) { //Doing the simulation until TIMESTEPS is reached
		//Looping through all oscillators and doing the Runge-Kutta-4
		for (int rungeStep = 0; rungeStep < 4; rungeStep++) { //Looping through the 4 runge-steps
			for (int i = 0; i < NUMBER_OSCILLATORS; i++) { //Looping through all oscillators and calculating dx for this step
					oscillators[i]->rungeKutta(oscillators, rungeStep, VARIABLE_B);
			}

			//Adding for all oscillators the new part step
			for (int i = 0; i < NUMBER_OSCILLATORS; i++) { 
				if (rungeStep < 2) {
					oscillators[i]->nextRungeStep(rungeStep, STEP_SIZE/2); //Adding this dx on the original coordinate to get the temporary new step marked with index 0-3
				}
				else {
					oscillators[i]->nextRungeStep(rungeStep, STEP_SIZE); //Adding this dx on the original coordinate to get the temporary new step marked with index 0-3
				}
			}
		}
		//Finally calculating the real new coordinate from the arithmetic mean of the rungesteps
		for (int i = 0; i < NUMBER_OSCILLATORS; i++) {
			oscillators[i]->finalRungeStep(STEP_SIZE);
		}

		//Couts the steps so the simulation can be followed
		std::cout << steps << std::endl;

		//Putting Data into the File
		outputFile << oscillators[0]->getX(0) << "	" << oscillators[5]->getX(0) << "	" << oscillators[50]->getX(0) << "	" << oscillators[75]->getX(0) << "	" << steps << "\n";

		//Incrementing the steps
		steps++;
	}

	//Closing the file
	outputFile.close();

	//So the console doesn´t close immediatly
	std::cout << "ALL DONE!\n";
	int tmp;
	std::cin >> tmp;
}